# ex: set syntax=python:					-*-python-*-

# This is the buildmaster config file for the Unified Build Candidate
# Project for LinuxCNC. It must be installed as 'master.cfg' in your
# buildmaster's base directory.
# 
# Author: Kent A Reed, based on master.cfg.sample file included in
# BuildBot distro
#
# Version 1 (I don't like 'point' versions for configuration files):
#
# In this version, everything is done explicitly. No cleverness with
# variables, builders, with Python scripts, with most anything. Mostly
# I ignored the "fleet" of predefined buildStep Classes/commands and
# used shell scripts.
#

####### VARIABLES

# Debug flag (True or False)
debug = True
if debug:
    from pprint import pprint

####### CONFIG

# Read in host and builder configuration from 'config.yaml'
#
# See 'config.yaml.sample' for notes about format
#
import os, yaml
try:
    basedir
    outside_buildbot = False
except:
    # basedir not defined; this script not called from buildbot
    basedir = os.path.dirname(os.path.realpath(__file__))
    outside_buildbot = True
configs = \
    yaml.load(open(os.path.join(basedir,'config.yaml'),'r').read())

# get defaults
builder_defaults = configs['builders'].pop('DEFAULT',{})
slave_defaults = configs['slaves'].pop("DEFAULT",{})


# Init the dictionary that the buildmaster pays attention to. We
# also use a shorter alias to save typing.

c = BuildmasterConfig = {
    'slaves' : [],
    'schedulers' : [],
    'change_source' : [],
    'builders' : [],
    'status' : [],
    }

# Set the umask
if configs['global'].has_key('umask'):
    if debug:
        print "Setting umask to %s" % oct(configs['global']['umask'])
    os.umask(configs['global']['umask'])

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each
# element is a BuildSlave object, specifying a unique slave name and
# password.  The same slave name and password must be configured on
# the slave.
#
# note: max_builds= is used to limit the cpu burden. The host may be
# capable of more
#
# note: no harm to define some "future" slaves which don't exist yet

from buildbot.buildslave import BuildSlave
for (host, params) in configs['slaves'].items():

    # Copy the slave_defaults dict and merge parameters
    slave_params = slave_defaults.copy()
    slave_params.update(params)

    # 'password' is a positional parameter; remove from params dict
    secret = slave_params.pop('secret',None)

    if debug:
        print("Adding slave, name='%s', secret='%s[...]'" % (host,secret[:3]))

    # Create the build slave object
    c['slaves'].append(
        BuildSlave(host, secret, **slave_params))

# 'slavePortnum' defines the TCP port to listen on for connections
#  from slaves.  The default is 9989. This must match the value
#  configured into the buildslaves (with their --master option)

c['slavePortnum'] = configs['global'].get('slavePortnum',9989)

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find
# out about source code changes.  Here we poll the configured branch
# of the configured git repo every 5 minutes note: there can be only
# one GitPoller pointing at a given repository

from buildbot.changes.gitpoller import GitPoller
from buildbot.changes.pb import PBChangeSource
for (csname,csconfig) in configs['change_source'].items():
    if debug:
        print ("Adding changesource config '%s'" % csname)
    cstype = csconfig.pop('type','(type not specified)')
    if cstype == 'poller':
        # 'repourl' is not a kwarg in buildbot 0.8.6
        repourl = csconfig.pop('repourl')
        c['change_source'].append(GitPoller(repourl, **csconfig))
        if debug:
            print ('    ' + '\n    '.join(['='.join((i[0],str(i[1])))
                                           for i in csconfig.items()]))
    elif cstype == 'PBChangeSource':
        # grab the password from the 'auth' dict
        csconfig['passwd'] = configs['auth'][csconfig['user']]
        c['change_source'].append(PBChangeSource(**csconfig))
        if debug:
            print ('    user: %s; passwd: %s[...]' % \
                       (csconfig['user'],
                        csconfig['passwd'][:3]))
    else:
        print ("Error:  Unknown poller type in config:  %s" % cstype)
        raise

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to
# perform a build:
#
# what steps, and which slaves can execute them.  Note that any
# particular build will only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.steps.master import MasterShellCommand
from buildbot.steps.transfer import FileDownload
from buildbot.process.properties import Property

def prop_dict(properties):
    '''
    Build dict of properties with name as key and 'Property()' as value
    http://docs.buildbot.net/latest/manual/cfg-properties.html#property
    '''
    res = {}
    for property in properties:
        res[property] = Property(property)
    return res

# Read build factories from config
factories = {}
for (bfname,bfconf) in configs['buildfactories'].items():
    if debug:
        print "Adding factory %s" % bfname
    bf = factories[bfname] = BuildFactory()
    # First step will always be to grab the buildsteps script, if
    # configured; this needs to be forced in case of updates
    if bfconf.get('buildsteps-script',None) is not None:
        if debug:
            print "    Adding buildsteps step, source=%s" % \
                bfconf['buildsteps-script']
        bf.addStep(FileDownload(mastersrc=bfconf['buildsteps-script'],
                                slavedest="buildsteps.sh"))
    
    # Now process each step
    for stepconf in bfconf['steps']:
        # Gather configuration
        steptype = stepconf.pop('type','script')
        stepargs = {
            'haltOnFailure' : True }
        stepargs.update(stepconf)

        if debug:
            print "    Adding %s step %s, workdir %s" % \
                (steptype, stepargs['name'],
                 stepargs.get('workdir','<default>'))

        if steptype == 'source.git':
            # Pull from git
            if debug:
                print "      Repo: %s" % stepargs['repourl']
            bf.addStep(Git(**stepargs))

        elif steptype == 'script':
            # Run 'buildsteps.sh'

            # Any key/value pairs in the 'env' dict will show up as
            # buildsteps.sh environment variables.
            #
            # Any property names in the 'env-properties' list will
            # also show up as environment variables with values filled
            # out.
            stepargs.setdefault('env',{}).update(
                prop_dict(stepargs.pop('env-properties',[])))

            # Set up the buildsteps.sh command
            stepargs['command'] = [ "/bin/bash", "-xe",
                                    "./buildsteps.sh",
                                    stepargs['name'] ]

            # If the 'server-side' key is 'True', run the script on
            # the server; otherwise, run on the slave (default).
            if stepargs.pop('server-side',False):
                bf.addStep(MasterShellCommand(**stepargs))
            else:
                bf.addStep(ShellCommand(**stepargs))

# finally, define builders. Each associates a buildfactory with one or
# more buildslaves.
#
# note: category= is used to segregate builders still in test from
#                 production builders haven't used this yet
#
# note: can't define "future" builders; seems to give buildbot a
# tummyache
#
# note: can reduce length of buildslave dirs by adding
# "builddir="<shortname>" after "name=" on each BuilderConfig

from buildbot.config import BuilderConfig

for (buildername,builderconfig_raw) in configs['builders'].items():

    # Merge default parameters
    builderconfig = builder_defaults.copy()
    builderconfig.update(builderconfig_raw)

    # filter list of slaves by class
    slavenames = []
    for (slavename,slaveconfig) in configs['slaves'].items():
        # Check each 'slaveclasses' key/value pair matches
        match = True
        for (key,value) in builderconfig.get('slaveclasses',{}).items():
            if not slaveconfig['properties'].has_key(key) or \
                    slaveconfig['properties'][key] != value:
                match = False
                break
        # Add matching slaves' names to list
        if match:
            slavenames.append(slavename)

    # Don't create builders for an empty slave list
    if not slavenames:
        # Remove the builder so it doesn't end up in a scheduler below
        configs['builders'].pop(buildername)

        print ("builder '%s': No slaves; removing from config" %
               buildername)
        continue

    # Create builder config objects for the specified factory
    factory = factories[builderconfig['factory']]
    c['builders'].append(
        BuilderConfig(name=buildername,
                      slavenames=slavenames,
                      factory=factory))

    if debug:
        print ("builder '%s', factory '%s', slaves:\n    %s" %
               (buildername, factory, ', '.join(slavenames)))


####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming
# changes.  In this version, just trigger a cycle of build and
# runtests on the branch.
#
# Note we also support forced builds.
#
# treeStableTimer determines how long after the last detected change
# the scheduler waits before triggering the builders.

import buildbot.schedulers.basic
import buildbot.schedulers.forcesched
from buildbot.changes.filter import ChangeFilter

buildschedulermap = {
    'AnyBranchScheduler' : buildbot.schedulers.basic.AnyBranchScheduler,
    'SingleBranchScheduler' : buildbot.schedulers.basic.SingleBranchScheduler,
    'ForceScheduler' : buildbot.schedulers.forcesched.ForceScheduler,
    'Dependent' : buildbot.schedulers.basic.Dependent,
    }

import subprocess
def contains_commit_callback(revision):
    '''
    Given a revision, return a callback that returns True if the
    provided Change set is an ancestor

    Used as the 'filter_fn' in a 'contains_commit' ChangeFilter
    '''
    # this callback returns True if the change set is an ancestor of
    # the specified revision
    def callback(change):
        ''' Return True if 'change' is an ancestor of commit %s ''' % revision
        # run 'git branch --contains <revision>'
        p = subprocess.Popen(["git",
                              "--git-dir", change.repository,
                              "branch", "-a",
                              "--contains", revision ],
                             stdout=subprocess.PIPE)
        # split output into list of branches
        ancestor_branches = [s.strip() for s in p.communicate()[0].split('\n')]

        return change.branch in ancestor_branches

    return callback

# get builder defaults
builder_default_factory = builder_defaults.get('factory',None)

# A dict for easy lookup of upstream schedulers
scheduler_dict = {}

# process scheduler config list
for (name,config) in configs['schedulers'].items():
    # Match up builderconfigs by matching type and other params

    # Init arg dict
    scheduler_args = { 'name' : name,
                       'builderNames' : []}

    if debug:
        print "Adding scheduler '%s', class %s" % \
            (name, config['class'])

    # Build list of matching builderconfigs
    for (bcname,bcconfig) in configs['builders'].items():

        # get the builder's factory
        factory = bcconfig.get("factory",builder_default_factory)

        # add to the list if class matches
        if config['builder_type'] == factory:
            if debug:
                print "    Adding builder %s to scheduler" % bcname
            scheduler_args['builderNames'].append(bcname)

    # Get the scheduler class
    scheduler_class = buildschedulermap[config['class']]

    # The 'Dependent' class needs the upstream scheduler object
    if config['class'] == 'Dependent':
        scheduler_args['upstream'] = scheduler_dict[config['upstream']]
        if debug:
            print "    upstream scheduler:  %s" % \
                scheduler_args['upstream'].name

    # Add a filter
    # http://docs.buildbot.net/latest/manual/cfg-schedulers.html#change-filters
    if config.has_key('change_filter'):
        filt = config['change_filter']
        if filt['type'] == 'contains_commit':
            scheduler_args['change_filter'] = ChangeFilter(
                filter_fn = contains_commit_callback(filt['commit']))
            if debug:
                print "    Filtering branches containing commit %s" % \
                    filt['commit']
        else:
            print ("Error:  unknown filter type '%s'" % filt['type'])
            raise

    # Create the scheduler object
    scheduler = scheduler_class(**scheduler_args)
    c['schedulers'].append(scheduler)
    scheduler_dict[name] = scheduler


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will
# be pushed to these targets. buildbot/status/*.py has a variety to
# choose from, including web pages, email senders, and IRC bots.
#
# In this version, only WebStatus is used.
#
# note: the docs make me believe I can use categories= here but
#       checkconfig disagrees???
#
# note: adding "order_console_by_time=True" to WebStatus to make the
#       console view work (cf: trac.buildbot.net/wiki/FAQ) - sadly,
#       does nothing for forced builds but console view now displays
#       git change info...pretty cool!

from buildbot.status import html
from buildbot.status.web import authz, auth

if debug:
    print "Adding basic auth with users:  %s" % \
        ', '.join(configs['auth'].keys())

for (name,config) in configs['status'].items():
    if config.has_key('authz'):
        authzconfig = config.pop('authz')
        authclass = authzconfig.pop('class','BasicAuth')
        if authclass == 'BasicAuth':
            # all we support right now
            authzconfig['auth'] = auth.BasicAuth(configs['auth'].items())
        else:
            print "Unsupported auth class '%s'" % authclass
            sys.exit(1)
        
        config['authz'] = authz.Authz(**authzconfig)

    statusclass = config.pop('class','WebStatus')
    if statusclass == 'WebStatus':
        if debug:
            print "Adding WebStatus"
        c['status'].append(html.WebStatus(**config))
    else:
        print "Unsuported status class '%s'" % statusclass
        sys.exit(1)

####### PROJECT IDENTITY

c.update(configs['identity'])

####### DB URL

c['db'] = configs['db']
