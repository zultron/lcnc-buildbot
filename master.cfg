# ex: set syntax=python:					-*-python-*-

# This is the buildmaster config file for the Unified Build Candidate
# Project for LinuxCNC. It must be installed as 'master.cfg' in your
# buildmaster's base directory.
# 
# Author: Kent A Reed, based on master.cfg.sample file included in
# BuildBot distro
#
# Version 1 (I don't like 'point' versions for configuration files):
#
# In this version, everything is done explicitly. No cleverness with
# variables, builders, with Python scripts, with most anything. Mostly
# I ignored the "fleet" of predefined buildStep Classes/commands and
# used shell scripts.
#

####### VARIABLES

# Debug flag (True or False)
debug = False
if debug:
    from pprint import pprint

####### CONFIG

# Read in host and builder configuration from 'config.yaml'
#
# See 'config.yaml.sample' for notes about format
#
import os, yaml
try:
    basedir
    outside_buildbot = False
except:
    # basedir not defined; this script not called from buildbot
    basedir = os.path.dirname(os.path.realpath(__file__))
    outside_buildbot = True
configs = yaml.load(open(os.path.join(basedir,'config.yaml'),'r').read())
slaves = configs['slaves']
builderconfigs = configs['builderconfigs']
authusers = configs['auth']
changesources = configs['changesources']
buildfactories = configs['buildfactories']
globalconfigs = configs.get('global',{})

# Configuration is less irritating if a temporarily missing slave
# doesn't require also commenting out builders with only missing
# slaves.  Simply remove builders with missing slaves and print a
# warning in case the admin really does need to go prune the config.

for (buildername,builderslaves) in builderconfigs.items():
    # build pruned list
    newlist = builderconfigs[buildername] = \
        [ bs for bs in builderslaves if bs in slaves ]
    # build list of prunings
    missinglist = [ bs for bs in builderslaves if bs not in slaves ]
    # builders with empty lists should be disabled
    if not newlist:
        print ("builder config '%s': No slaves; removing" %
               buildername)
        builderconfigs.pop(buildername)
        continue
    if len(missinglist) > 0:
        print ("builder config '%s': Missing slaves removed: %s" %
               (buildername, ', '.join(missinglist)))


# Init the dictionary that the buildmaster pays attention to. We
# also use a shorter alias to save typing.

c = BuildmasterConfig = {
    'slaves' : [],
    'schedulers' : [],
    'change_source' : [],
    'builders' : [],
    'status' : [],
    }

# Set the umask
if globalconfigs.has_key('umask'):
    if debug:
        print "Setting umask to %s" % oct(globalconfigs['umask'])
    os.umask(globalconfigs['umask'])

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each
# element is a BuildSlave object, specifying a unique slave name and
# password.  The same slave name and password must be configured on
# the slave.
#
# note: max_builds= is used to limit the cpu burden. The host may be
# capable of more
#
# note: no harm to define some "future" slaves which don't exist yet

from buildbot.buildslave import BuildSlave
for (host, passwd) in slaves.items():
    if debug:
        print("Adding slave, name='%s', passwd='%s[...]'" % (host,passwd[:3]))
    c['slaves'].append(
        BuildSlave(host, passwd, max_builds=1))


# 'slavePortnum' defines the TCP port to listen on for connections
#  from slaves.  The default is 9989. This must match the value
#  configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find
# out about source code changes.  Here we poll the configured branch
# of the configured git repo every 5 minutes note: there can be only
# one GitPoller pointing at a given repository

from buildbot.changes.gitpoller import GitPoller
for (csname,csconfig) in changesources.items():
    if debug:
        print ("Adding changesource config '%s':" % csname)
        print ('    ' + '\n    '.join(['='.join((i[0],str(i[1])))
                                       for i in csconfig.items()]))
    cstype = csconfig.pop('type','(type not specified)')
    if cstype == 'poller':
        # 'repourl' is not a kwarg in buildbot 0.8.6
        repourl = csconfig.pop('repourl')
        c['change_source'].append(GitPoller(repourl, **csconfig))
    # (add more poller types here)
    # elif cstype == ....
    else:
        print ("Error:  Unknown poller type in config:  %s" % cstype)
        raise

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to
# perform a build:
#
# what steps, and which slaves can execute them.  Note that any
# particular build will only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.steps.master import MasterShellCommand
from buildbot.steps.transfer import FileDownload
from buildbot.process.properties import Property

def prop_dict(properties):
    '''
    Build dict of properties with name as key and 'Property()' as value
    http://docs.buildbot.net/latest/manual/cfg-properties.html#property
    '''
    res = {}
    for property in properties:
        res[property] = Property(property)
    return res

# Read build factories from config
factories = {}
for (bfname,bfconf) in buildfactories.items():
    if debug:
        print "Adding factory %s" % bfname
    bf = factories[bfname] = BuildFactory()
    # First step will always be to grab the buildsteps script, if
    # configured; this needs to be forced in case of updates
    if bfconf.get('buildsteps-script',None) is not None:
        if debug:
            print "    Adding buildsteps step, source=%s" % \
                bfconf['buildsteps-script']
        bf.addStep(FileDownload(mastersrc=bfconf['buildsteps-script'],
                                slavedest="buildsteps.sh"))
    
    # Now process each step
    for stepconf in bfconf['steps']:
        # Gather configuration
        steptype = stepconf.pop('type','script')
        stepargs = {
            'haltOnFailure' : True }
        stepargs.update(stepconf)

        if debug:
            print "    Adding %s step %s, workdir %s" % \
                (steptype, stepargs['name'],
                 stepargs.get('workdir','<default>'))

        if steptype == 'source.git':
            # Pull from git
            if debug:
                print "      Repo: %s" % stepargs['repourl']
            bf.addStep(Git(**stepargs))

        elif steptype == 'script':
            # Run 'buildsteps.sh'

            # Any key/value pairs in the 'env' dict will show up as
            # buildsteps.sh environment variables.
            #
            # Any property names in the 'env-properties' list will
            # also show up as environment variables with values filled
            # out.
            stepargs.setdefault('env',{}).update(
                prop_dict(stepargs.pop('env-properties',[])))

            # Set up the buildsteps.sh command
            stepargs['command'] = [ "/bin/bash", "-xe",
                                    "./buildsteps.sh",
                                    stepargs['name'] ]

            # If the 'server-side' key is 'True', run the script on
            # the server; otherwise, run on the slave (default).
            if stepargs.pop('server-side',False):
                bf.addStep(MasterShellCommand(**stepargs))
            else:
                bf.addStep(ShellCommand(**stepargs))

# finally, define builders. Each associates a buildfactory with one or
# more buildslaves.
#
# note: category= is used to segregate builders still in test from
#                 production builders haven't used this yet
#
# note: can't define "future" builders; seems to give buildbot a
# tummyache
#
# note: can reduce length of buildslave dirs by adding
# "builddir="<shortname>" after "name=" on each BuilderConfig

from buildbot.config import BuilderConfig

buildernames = []
for (buildershortname,builderslaves) in builderconfigs.items():
    if debug:
        print ("builder config '%s', slaves:  %s" %
               (buildershortname, ', '.join(builderslaves)))
    for bfname in buildfactories.keys():
        buildername = "%s-%s" % (buildershortname, bfname)
        buildernames.append(buildername)
        if debug:
            print ("   adding with build factory %s as %s" % \
                       (bfname,buildername))
        c['builders'].append(
            BuilderConfig(name=buildername,
                          slavenames=builderslaves,
                          factory=factories[bfname],
                          category="production"))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming
# changes.  In this version, just trigger a cycle of build and
# runtests on the branch.
#
# Note we also support forced builds.
#
# treeStableTimer determines how long after the last detected change
# the scheduler waits before triggering the builders.

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes import filter
for (csname,csconfig) in changesources.items():
    if csconfig.get('branch',None):
        branches = [csconfig['branch']]
    else:
        branches = csconfig['branches']
    for branch in branches:
        if debug:
            print "Adding SingleBranchScheduler '%s-%s-all'" % (csname,branch)
        c['schedulers'].append(SingleBranchScheduler(
                name="%s-%s-all" % (csname,branch),
                change_filter=filter.ChangeFilter(
                    branch=branch),
                treeStableTimer=180,
                builderNames=buildernames,
                ))
    if debug:
        print "Adding ForceScheduler '%s-force'" % csname
    c['schedulers'].append(ForceScheduler(
            name="%s-force" % csname,
            builderNames=buildernames,
            ))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will
# be pushed to these targets. buildbot/status/*.py has a variety to
# choose from, including web pages, email senders, and IRC bots.
#
# In this version, only WebStatus is used.
#
# note: the docs make me believe I can use categories= here but
#       checkconfig disagrees???
#
# note: adding "order_console_by_time=True" to WebStatus to make the
#       console view work (cf: trac.buildbot.net/wiki/FAQ) - sadly,
#       does nothing for forced builds but console view now displays
#       git change info...pretty cool!

from buildbot.status import html
from buildbot.status.web import authz, auth

if debug:
    print "Adding basic auth with users:  %s" % ', '.join(authusers.keys())

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth(authusers.items()),
    gracefulShutdown = True,
    forceBuild = 'auth', # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = True,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = True,
)
c['status'].append(
    html.WebStatus(
        http_port=8010, authz=authz_cfg, order_console_by_time=True))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the 'titleURL')
# and is embedded in the title of the waterfall HTML page.

c['title'] = "Unified Build Candidate"
c['titleURL'] = "https://github.com/mhaberler"

# the 'buildbotURL' string should point to the location where the
# buildbot's internal web server (usually the html.WebStatus page) is
# visible. This typically uses the port number set in the Waterfall
# 'status' entry, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.
    # You can leave this at its default for all but the largest
    # installations.
    'db_url' : "sqlite:///state.sqlite",
}
